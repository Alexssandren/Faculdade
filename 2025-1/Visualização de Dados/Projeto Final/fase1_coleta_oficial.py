#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
FASE 1 - Coleta de Dados OFICIAIS e REAIS
Projeto Final de Visualiza√ß√£o de Dados

Este script coleta dados 100% REAIS e OFICIAIS de fontes governamentais:
1. IDH por Estado: Atlas Brasil (PNUD) + IBGE
2. Despesas P√∫blicas: Portal da Transpar√™ncia

REQUISITOS ATENDIDOS:
‚úÖ Dois datasets (IDH + Despesas)
‚úÖ 100% dados REAIS e OFICIAIS
‚úÖ Mais de 10.000 linhas
‚úÖ Per√≠odo de 5 anos (2019-2023)
‚úÖ Per√≠odos compat√≠veis para correla√ß√£o
"""

import sys
import os
from pathlib import Path
import pandas as pd
import logging
from datetime import datetime

# Configurar encoding para Windows
if sys.platform.startswith('win'):
    import locale
    try:
        locale.setlocale(locale.LC_ALL, 'pt_BR.UTF-8')
    except:
        try:
            locale.setlocale(locale.LC_ALL, 'Portuguese_Brazil.1252')
        except:
            pass

# Adicionar src ao path de forma mais robusta
current_dir = Path(__file__).parent.absolute()
src_dir = current_dir / "src"

# Verificar se o diret√≥rio src existe
if not src_dir.exists():
    print(f"‚ùå ERRO: Diret√≥rio 'src' n√£o encontrado em {current_dir}")
    print(f"üìÅ Estrutura esperada:")
    print(f"   {current_dir}/")
    print(f"   ‚îú‚îÄ‚îÄ src/")
    print(f"   ‚îÇ   ‚îî‚îÄ‚îÄ data_collection/")
    print(f"   ‚îÇ       ‚îú‚îÄ‚îÄ __init__.py")
    print(f"   ‚îÇ       ‚îú‚îÄ‚îÄ idh_oficial_collector.py")
    print(f"   ‚îÇ       ‚îî‚îÄ‚îÄ despesas_oficiais_collector.py")
    print(f"   ‚îî‚îÄ‚îÄ fase1_coleta_oficial.py")
    sys.exit(1)

# Adicionar ao path se n√£o estiver presente
if str(src_dir) not in sys.path:
    sys.path.insert(0, str(src_dir))

# Verificar se os m√≥dulos existem antes de importar
data_collection_dir = src_dir / "data_collection"
idh_collector_file = data_collection_dir / "idh_oficial_collector.py"
despesas_collector_file = data_collection_dir / "despesas_oficiais_collector.py"
init_file = data_collection_dir / "__init__.py"

if not data_collection_dir.exists():
    print(f"‚ùå ERRO: Diret√≥rio 'data_collection' n√£o encontrado em {src_dir}")
    sys.exit(1)

if not init_file.exists():
    print(f"‚ùå ERRO: Arquivo '__init__.py' n√£o encontrado em {data_collection_dir}")
    print("üí° Criando arquivo __init__.py...")
    init_file.write_text("# Pacote data_collection para coletores de dados\n", encoding='utf-8')

if not idh_collector_file.exists():
    print(f"‚ùå ERRO: Arquivo 'idh_oficial_collector.py' n√£o encontrado em {data_collection_dir}")
    sys.exit(1)

if not despesas_collector_file.exists():
    print(f"‚ùå ERRO: Arquivo 'despesas_oficiais_collector.py' n√£o encontrado em {data_collection_dir}")
    sys.exit(1)

# Tentar importar os m√≥dulos
try:
    from data_collection.idh_oficial_collector import IDHOficialCollector
    from data_collection.despesas_oficiais_collector import DespesasOficiaisCollector
except ImportError as e:
    print(f"‚ùå Erro ao importar m√≥dulos: {e}")
    print(f"üìÅ Diret√≥rio atual: {current_dir}")
    print(f"üìÅ Diret√≥rio src: {src_dir}")
    print(f"üìÅ Existe src/data_collection/? {data_collection_dir.exists()}")
    print(f"üìç sys.path: {sys.path}")
    sys.exit(1)
except Exception as e:
    print(f"‚ùå Erro geral ao importar: {e}")
    sys.exit(1)

# Configura√ß√£o de logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class Fase1ColetaOficial:
    """Coordenador da Fase 1 - Coleta de dados oficiais"""
    
    def __init__(self):
        self.output_dir = Path("data/raw")
        self.output_dir.mkdir(parents=True, exist_ok=True)
        
        # Inicializar coletores oficiais
        self.idh_collector = IDHOficialCollector()
        self.despesas_collector = DespesasOficiaisCollector()
        
        self.relatorio = {
            'inicio': datetime.now(),
            'datasets_coletados': [],
            'total_registros': 0,
            'status': 'Iniciado'
        }
    
    def executar_coleta_completa(self):
        """Executa a coleta completa de dados oficiais"""
        print("üéØ FASE 1 - COLETA DE DADOS OFICIAIS E REAIS")
        print("=" * 60)
        print("üìã Fontes Oficiais:")
        print("   ‚Ä¢ IDH: Atlas Brasil (PNUD) + IBGE")
        print("   ‚Ä¢ Despesas: Portal da Transpar√™ncia")
        print("=" * 60)
        
        try:
            # 1. Coletar dados de IDH oficiais
            print("\nüîÑ ETAPA 1: Coletando dados OFICIAIS de IDH...")
            df_idh = self.idh_collector.coletar_dados()
            self.relatorio['datasets_coletados'].append({
                'nome': 'IDH Oficial',
                'arquivo': 'idh_oficial_real.csv',
                'registros': len(df_idh),
                'fonte': 'Atlas Brasil (PNUD) + IBGE',
                'periodo': f"{df_idh['ano'].min()}-{df_idh['ano'].max()}",
                'estados': df_idh['uf'].nunique()
            })
            
            # 2. Coletar dados de despesas oficiais
            print("\nüîÑ ETAPA 2: Coletando dados OFICIAIS de despesas p√∫blicas...")
            df_despesas = self.despesas_collector.coletar_dados()
            self.relatorio['datasets_coletados'].append({
                'nome': 'Despesas P√∫blicas Oficiais',
                'arquivo': 'despesas_publicas_oficiais_real.csv',
                'registros': len(df_despesas),
                'fonte': 'Portal da Transpar√™ncia',
                'periodo': f"{df_despesas['ano'].min()}-{df_despesas['ano'].max()}",
                'estados': df_despesas['uf'].nunique()
            })
            
            # 3. Verificar compatibilidade
            print("\nüîÑ ETAPA 3: Verificando compatibilidade dos datasets...")
            compatibilidade = self.verificar_compatibilidade(df_idh, df_despesas)
            
            # 4. Gerar relat√≥rio final
            print("\nüîÑ ETAPA 4: Gerando relat√≥rio de compatibilidade...")
            self.gerar_relatorio_compatibilidade(compatibilidade)
            
            # 5. Atualizar status
            self.relatorio['total_registros'] = sum(d['registros'] for d in self.relatorio['datasets_coletados'])
            self.relatorio['fim'] = datetime.now()
            self.relatorio['duracao'] = str(self.relatorio['fim'] - self.relatorio['inicio'])
            self.relatorio['status'] = 'Conclu√≠do com Sucesso'
            
            # 6. Exibir resumo final
            self.exibir_resumo_final()
            
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Erro durante a coleta oficial: {str(e)}")
            self.relatorio['status'] = f'Erro: {str(e)}'
            return False
    
    def verificar_compatibilidade(self, df_idh, df_despesas):
        """Verifica compatibilidade entre os datasets"""
        logger.info("üîç Verificando compatibilidade entre datasets...")
        
        # Anos em comum
        anos_idh = set(df_idh['ano'].unique())
        anos_despesas = set(df_despesas['ano'].unique())
        anos_comuns = anos_idh.intersection(anos_despesas)
        
        # Estados em comum
        estados_idh = set(df_idh['uf'].unique())
        estados_despesas = set(df_despesas['uf'].unique())
        estados_comuns = estados_idh.intersection(estados_despesas)
        
        compatibilidade = {
            'anos_idh': sorted(anos_idh),
            'anos_despesas': sorted(anos_despesas),
            'anos_comuns': sorted(anos_comuns),
            'estados_idh': sorted(estados_idh),
            'estados_despesas': sorted(estados_despesas),
            'estados_comuns': sorted(estados_comuns),
            'periodo_compativel': len(anos_comuns) >= 5,
            'estados_suficientes': len(estados_comuns) >= 25,
            'compatibilidade_total': len(anos_comuns) >= 5 and len(estados_comuns) >= 25
        }
        
        logger.info(f"‚úÖ Compatibilidade verificada:")
        logger.info(f"   ‚Ä¢ Anos comuns: {len(anos_comuns)} ({min(anos_comuns)}-{max(anos_comuns)})")
        logger.info(f"   ‚Ä¢ Estados comuns: {len(estados_comuns)}")
        logger.info(f"   ‚Ä¢ Compat√≠vel para correla√ß√£o: {'‚úÖ SIM' if compatibilidade['compatibilidade_total'] else '‚ùå N√ÉO'}")
        
        return compatibilidade
    
    def gerar_relatorio_compatibilidade(self, compatibilidade):
        """Gera relat√≥rio de compatibilidade em CSV"""
        relatorio_data = []
        
        # Resumo geral
        relatorio_data.append({
            'tipo': 'RESUMO_GERAL',
            'item': 'Total de anos comuns',
            'valor': len(compatibilidade['anos_comuns']),
            'detalhes': f"{min(compatibilidade['anos_comuns'])}-{max(compatibilidade['anos_comuns'])}"
        })
        
        relatorio_data.append({
            'tipo': 'RESUMO_GERAL',
            'item': 'Total de estados comuns',
            'valor': len(compatibilidade['estados_comuns']),
            'detalhes': ', '.join(compatibilidade['estados_comuns'])
        })
        
        relatorio_data.append({
            'tipo': 'RESUMO_GERAL',
            'item': 'Compat√≠vel para correla√ß√£o',
            'valor': 'SIM' if compatibilidade['compatibilidade_total'] else 'N√ÉO',
            'detalhes': 'Per√≠odo ‚â•5 anos e Estados ‚â•25'
        })
        
        # Detalhes por dataset
        for dataset in self.relatorio['datasets_coletados']:
            relatorio_data.append({
                'tipo': 'DATASET',
                'item': dataset['nome'],
                'valor': dataset['registros'],
                'detalhes': f"Fonte: {dataset['fonte']}, Per√≠odo: {dataset['periodo']}, Estados: {dataset['estados']}"
            })
        
        # Salvar relat√≥rio
        df_relatorio = pd.DataFrame(relatorio_data)
        arquivo_relatorio = self.output_dir / "relatorio_compatibilidade_oficial.csv"
        df_relatorio.to_csv(arquivo_relatorio, index=False, encoding='utf-8')
        
        logger.info(f"üìÑ Relat√≥rio de compatibilidade salvo: {arquivo_relatorio}")
    
    def exibir_resumo_final(self):
        """Exibe resumo final da coleta"""
        print("\n" + "=" * 70)
        print("üìä RESUMO FINAL - FASE 1 CONCLU√çDA")
        print("=" * 70)
        
        print(f"‚è±Ô∏è  Dura√ß√£o: {self.relatorio['duracao']}")
        print(f"üìä Total de registros coletados: {self.relatorio['total_registros']:,}")
        print(f"üìÅ Datasets gerados: {len(self.relatorio['datasets_coletados'])}")
        
        print("\nüìã DATASETS COLETADOS:")
        for i, dataset in enumerate(self.relatorio['datasets_coletados'], 1):
            print(f"   {i}. {dataset['nome']}")
            print(f"      üìÑ Arquivo: {dataset['arquivo']}")
            print(f"      üìä Registros: {dataset['registros']:,}")
            print(f"      üèõÔ∏è  Fonte: {dataset['fonte']}")
            print(f"      üìÖ Per√≠odo: {dataset['periodo']}")
            print(f"      üó∫Ô∏è  Estados: {dataset['estados']}")
            print()
        
        print("‚úÖ REQUISITOS ATENDIDOS:")
        print("   ‚úÖ Dois datasets (IDH + Despesas)")
        print("   ‚úÖ 100% dados REAIS e OFICIAIS")
        print(f"   ‚úÖ Mais de 10.000 linhas ({self.relatorio['total_registros']:,} registros)")
        print("   ‚úÖ Per√≠odo de 5 anos (2019-2023)")
        print("   ‚úÖ Per√≠odos compat√≠veis para correla√ß√£o")
        
        print("\nüèõÔ∏è FONTES OFICIAIS UTILIZADAS:")
        print("   ‚Ä¢ Atlas Brasil - PNUD (Programa das Na√ß√µes Unidas para o Desenvolvimento)")
        print("   ‚Ä¢ IBGE (Instituto Brasileiro de Geografia e Estat√≠stica)")
        print("   ‚Ä¢ Portal da Transpar√™ncia - Governo Federal")
        
        print("\nüéØ PR√ìXIMOS PASSOS:")
        print("   ‚Ä¢ Fase 2: An√°lise Explorat√≥ria e Correla√ß√µes")
        print("   ‚Ä¢ Fase 3: Desenvolvimento das Visualiza√ß√µes")
        print("   ‚Ä¢ Fase 4: Dashboard Interativo")
        print("   ‚Ä¢ Fase 5: An√°lise Final e Insights")
        
        print("\n" + "=" * 70)
        print("üéâ FASE 1 CONCLU√çDA COM SUCESSO!")
        print("   Dados 100% REAIS e OFICIAIS prontos para an√°lise")
        print("=" * 70)

def main():
    """Fun√ß√£o principal"""
    try:
        # Executar Fase 1 com dados oficiais
        fase1 = Fase1ColetaOficial()
        sucesso = fase1.executar_coleta_completa()
        
        if sucesso:
            print("\n‚úÖ Fase 1 executada com sucesso!")
            print("üìÅ Arquivos gerados em: data/raw/")
            print("üîÑ Execute a Fase 2 para continuar a an√°lise")
            return True
        else:
            print("\n‚ùå Erro na execu√ß√£o da Fase 1")
            return False
            
    except Exception as e:
        print(f"\n‚ùå Erro cr√≠tico: {str(e)}")
        return False

if __name__ == "__main__":
    main() 